#!/bin/bash
# shellcheck disable=SC2046
# shellcheck disable=SC2086
# shellcheck disable=SC2140


Packager="Anagnostakis Ioannis (rizitis@gmail.com) GR"
   # All rights reserved 08/2024
# αμέ
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

cd "$(dirname "$0")" || exit 1
CWD=$(pwd)
DATE="$(date)"
# Setup build log file
LOGFILE="$CWD/build.log"
# shellcheck disable=SC2086
rm $LOGFILE || true
exec > >(tee -a "$LOGFILE") 2>&1

echo "Starting build process..."
start_time=$(date +%s)


##########################-slackdesc-README-####################################
# If you have slackdesc installed you need these, else ignore them (empty)
# https://slack-desc.sourceforge.net/
   mkdesc="$(which slackdesc)" || true
   Homepage="https://github.com/wangqr/Aegisub"
            #|--------------------------------------|#
   SortDesc="General-purpose subtitle editor"
            #|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|#
    LongDesc="A general-purpose subtitle editor"
# If a README or README.md dont exist in CWD then SortDec discribtion, if not empty, will be added in a README file.

##########################-GITHUB-AUTO UPDATE-#####################################
# If you dont use AUTO_UPD ignore them. (AUTO_UPD is used to following latest release/tag of a package without editting Slackbuild everytime...)
DEV=
PRJ=
AUTO_UPD=$(curl --silent -L "https://api.github.com/repos/$DEV/$PRJ/releases/latest" | jq -r '.tag_name' | sed 's/^v//')

############################-SRC AND PACKAGE VARS-##################################
# If use AUTO UPDATE 'VERSION=$AUTO_UPD'  or as a regular package version 'VERSION=0.1.2' etc...
VERSION=3.3.3
#
# Binary (output) name
PRGNAM=aegisub
# If not special SRCNAM needed then we use the same name as PRGNAM.
SRCNAM=aegisub-v3.3.3-x86-64.AppImage
# mdsum, if exist or empty.
MDSCHK= 
# Download link if use AUTO_UPD then SRCmust be empty
SRCURL="https://ocs-dl.fra1.cdn.digitaloceanspaces.com/data/files/1683370141/aegisub-v3.3.3-x86-64.AppImage?response-content-disposition=attachment%3B%2520aegisub-v3.3.3-x86-64.AppImage&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=RWJAQUNCHT7V2NCLZ2AL%2F20241103%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20241103T200807Z&X-Amz-SignedHeaders=host&X-Amz-Expires=3600&X-Amz-Signature=7e13176b2e7def3ea861cdac150e55fc851b556a888c3ac26e1b3341c4eafb68"
#
# ON or OFF/empty
AGENT=ON
# If AGENT is ON Define the download agent or special wget option...
DOWNLOAD_AGENT () {
wget -O "aegisub-v3.3.3-x86-64.AppImage" "$SRCURL" \
     --header="Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
     --header="Accept-Language: en-US,en;q=0.5" \
     --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"
}
# "--content-disposition"


# Supported COMPRESS types are: tar.gz, tar.xz, bz2, rar, gz, tar, tbz2, tgz, zip, Z, 7z, deb, rpm
# OR repos: cvn, cvs, git, lftp
COMPRESS="AppImage"
# IF you need:git checkout, else leave it empty.
GITCHEK=
#0bdb437d8cdf90902dcabe1d472c52e55fc0f46a bump version.
# When source package after extract contains just a binary or we build directly in then set BIN_PKG=YES else leave it empty or whatever but YES.
BIN_PKG=YES

######################-WORK_DIRS and OUTPUT-#################################
BUILD=${BUILD:-2}
TAG=${TAG:-_rtz}
PKGTYPE=${PKGTYPE:-tlz}
PKG=$CWD/package-$PRGNAM
TMP=$CWD/work
OUTPUT=$CWD/binary-$PRGNAM-$VERSION

##########################-Desktop-Entry-####################################
# ONLY if you need to create a Desktop entry edit it and call desktop_entry function in your build function, else just ignore it.
desktop_entry() {
mkdir -p "$PKG"/usr/share/applications
cat <<EOF > "$PKG"/usr/share/applications/aegisub.desktop
[Desktop Entry]
Version=1.0
Name=Aegisub
GenericName=Subtitle Editor
Comment=Aegisub AppImage repackage
Type=Application
PATH=/usr/local/bin/aegisub/usr/bin
Exec=sh -c "LD_LIBRARY_PATH=/usr/local/bin/aegisub/usr/lib /usr/local/bin/aegisub/usr/bin/aegisub $SHELL"
Icon=/usr/share/icons/hicolor/48x48/apps/aegisub.png
Terminal=false
Categories=AudioVideo;AudioVideoEditing;
StartupNotify=true
MimeType=application/x-srt;text/plain;text/x-ass;text/x-microdvd;text/x-ssa;
StartupWMClass=aegisub
EOF
}


## EDIT YOUR BUILD FUNCTIONS AS FOR YOUR NEEDS ##

   patch_build() {
   true
}

  custom_build () {
  export BOOST_ROOT=/usr
  export BOOST_LIBRARYDIR=/usr/lib64
  export BOOST_INCLUDEDIR=/usr/include
  export PKG_CONFIG_PATH=/usr/lib64/pkgconfig
  export CMAKE_PREFIX_PATH=/usr/lib64/cmake

  autoreconf -fiv
  CFLAGS="$SLKCFLAGS" \
  CPPFLAGS+=' -DU_USING_ICU_NAMESPACE=1' \
  CXXFLAGS="$CXXFLAGS -Wall -Wextra -Wno-unused-parameter -fno-strict-aliasing" \
  FORCE_GIT_VERSION="TRUE" \
  ./configure \
    --disable-update-checker \
    --prefix=/usr \
    --docdir=/usr/doc \
    --build=$(uname -m)-slackware-linux

  make
  make install DESTDIR=$PKG
  }

   auto_build() {
	CFLAGS="$SLKCFLAGS" \
	CXXFLAGS="$SLKCFLAGS" \
	./configure \
	  --prefix=/usr \
	  --libdir=/usr/lib${LIBDIRSUFFIX} \
	  --sysconfdir=/etc \
	  --localstatedir=/var \
	  --mandir=/usr/man \
	  --docdir=/usr/doc/$PRGNAM-"$VERSION" \
	  --disable-static \
	  --build="$ARCH"-slackware-linux

	make "$NUMJOBS"
	make install DESTDIR="$PKG"
   }

   meson_build(){
	  mkdir build
	  cd build
	  CFLAGS="$SLKCFLAGS" \
	  CXXFLAGS="$SLKCFLAGS" \
	  meson .. \
	    --buildtype=release \
	    --infodir=/usr/info \
	    --libdir=/usr/lib${LIBDIRSUFFIX} \
	    --localstatedir=/var \
	    --mandir=/usr/man \
	    --prefix=/usr \
	    --sysconfdir=/etc \
	    -Dstrip=true
	  "${NINJA:=ninja}" "$NUMJOBS"
	  DESTDIR=$PKG $NINJA install
	cd ..
   }

   python_build(){
	python2 setup.py install --root="$PKG"
	python3 setup.py install --root="$PKG"

	python3 -m build --wheel --no-isolation
	python3 -m installer --destdir "$PKG" dist/*.whl
   }

   cmake_build(){
   mkdir -p build
  cd build
  CFLAGS="$SLKCFLAGS" \
  CXXFLAGS="$SLKCFLAGS" \
  meson setup .. \
  --prefix=/usr \
  --buildtype=release \
  --libdir=lib${LIBDIRSUFFIX} \
  --libexecdir=/usr/libexec \
  --sysconfdir=/etc \
  --infodir=/usr/info \
  --mandir=/usr/man \
  --localstatedir=/var
   "${NINJA:=ninja}"
   DESTDIR=$PKG $NINJA install
cd ..
   }

   perl_build(){
        # Build method #1 (preferred)
        perl Makefile.PL \
  PREFIX=/usr \
  INSTALLDIRS=vendor \
  INSTALLVENDORMAN1DIR=/usr/man/man1 \
  INSTALLVENDORMAN3DIR=/usr/man/man3
        make
        make test
        make install DESTDIR="$PKG"

# Build method #2
# requires perl-Module-Build or perl-Module-Build-Tiny
        perl Build.PL \
          --installdirs vendor \
          --config installvendorman1dir=/usr/man/man1 \
          --config installvendorman3dir=/usr/man/man3
        ./Build
        ./Build test
        ./Build install \
          --destdir "$PKG"
   }

   haskel_build(){
	CFLAGS="$SLKCFLAGS" \
	CXXFLAGS="$SLKCFLAGS" \
	  runghc Setup configure \
	  --prefix=/usr \
	  --libdir=/usr/lib${LIBDIRSUFFIX} \
	  --libsubdir=ghc-"${GHC_VERSION}"/$SRCNAM-"$VERSION" \
	  --enable-shared \
	  --enable-library-profiling \
	  --docdir=/usr/doc/$PRGNAM-"$VERSION"


	  runghc Setup build
	  runghc Setup haddock
	  runghc Setup copy --destdir="$PKG"
	  runghc Setup register --gen-pkg-config

	PKGCONFD=/usr/lib${LIBDIRSUFFIX}/ghc-${GHC_VERSION}/package.conf.d
	PKGID=$( grep -E "^id: " $SRCNAM-"$VERSION".conf | cut -d" " -f2 )
	  mkdir -p "$PKG"/"$PKGCONFD"
	  mv $SRCNAM-"$VERSION".conf "$PKG"/"$PKGCONFD"/"$PKGID".conf
   }

   cargo_build() {

/usr/bin/cargo build --release

        install -Dm755 "target/release/$PRGNAM" "$PKG/usr/local/bin/$PRGNAM"

   }

# golang_build dont need root access in Slackware if your setup is as SlackBuilds.org suggest for go.
# examples for golang_build...
   golang_build(){
	  export CGO_CPPFLAGS="${CPPFLAGS}"
	  export CGO_CFLAGS="${CFLAGS}"
	  export CGO_CXXFLAGS="${CXXFLAGS}"
	  export CGO_LDFLAGS="${LDFLAGS}"

    go build -buildmode=pie -trimpath -mod=readonly -modcacherw -o "$PRGNAM"

  mkdir -p "$PKG"/usr/local/bin/
  install -Dm755 "$PRGNAM" "$PKG"/usr/local/bin/"$PRGNAM"
  }


  qmake6_build() {
      # Export necessary environment variables (optional if you want to make them available globally)
      export QMAKE_CFLAGS="$QMAKE_CFLAGS"
      export QMAKE_CXXFLAGS="$QMAKE_CXXFLAGS"
      export QMAKE_LFLAGS="$QMAKE_LFLAGS"

      # Call qmake6 with architecture-specific flags
      qmake6 \
          PREFIX="$PKG/usr" \
          QMAKE_CFLAGS+="$QMAKE_CFLAGS" \
          QMAKE_CXXFLAGS+="$QMAKE_CXXFLAGS" \
          QMAKE_LFLAGS+="$QMAKE_LFLAGS"

      # Run make with the number of parallel jobs set by NUMJOBS
      make "$NUMJOBS"

      # Install the compiled binaries
      make install
  }

  debian_build () {
  	pushd "$PKG"
	mkdir -p "$PKG"/usr
  mv "$PKG"/usr/share/man "$PKG"/usr || true
  popd
  }

  rpm_build () {
  cd "$PKG"
  cpio -i -m -d < "$TMP"/"$SRCNAM"."$COMPRESS".cpio
  mkdir -p "$PKG"/usr
  mv "$PKG"/usr/share/man "$PKG"/usr || true
  }

  appimage_build () {
  mkdir -p "$PKG"/usr/local/bin/"$PRGNAM"
  mkdir -p "$PKG"/usr/share/doc/"$PRGNAM-$VERSION"
  pushd "$PKG"/usr/local/bin/
  cd "$TMP" || exit
  chmod +x "$SRCNAM"
  ./"$SRCNAM" --appimage-extract
  mv squashfs-root/usr/share/icons "$PKG"/usr/share
  mv squashfs-root/usr/share/doc/* "$PKG"/usr/share/doc/"$PRGNAM-$VERSION"/
  rm -r squashfs-root/usr/share
  cp -R squashfs-root/usr "$PKG"/usr/local/bin/"$PRGNAM"/
  popd
  desktop_entry
  }


   after_build(){
if [[ $COMPRESS != "rpm" && $COMPRESS != "deb" ]]; then
	  mkdir -p "$PKG"/usr/doc/$PRGNAM-"$VERSION"

# files...
   cp  AUTHORS ChangeLog* COPYING CREDITS LICENSE MAINTAINERS NEWS README* "$PKG/usr/doc/$PRGNAM-$VERSION/" || true
 #find . -maxdepth 1 -type f -exec cp -a {} "$PKG/usr/doc/$PRGNAM-$VERSION/" \;


# Iterate over directories in the current directory and copy them
   cp -R docs DOCS "$PKG/usr/doc/$PRGNAM-$VERSION/" || true
 #find . -maxdepth 1 -type d ! -name . -exec cp -R {} "$PKG/usr/doc/$PRGNAM-$VERSION/" \;


   cat "$CWD"/$PRGNAM.SlackBuild > "$PKG"/usr/doc/$PRGNAM-"$VERSION"/$PRGNAM.SlackBuild
	  find "$PKG"/usr/doc/$PRGNAM-"$VERSION" -type f -exec chmod 644 {} \;

	  mkdir -p "$PKG"/install
        if [ -f "$CWD"/doinst.sh ]; then
	  cat "$CWD"/doinst.sh >> "$PKG"/install/doinst.sh
	elif [ -f "$CWD"/doinst.sh.gz ]; then
	  zcat "$CWD"/doinst.sh.gz >> "$PKG"/install/doinst.sh
	else

  cat <<MKINS >> "$PKG"/install/doinst.sh
        config() {
          for infile in \$1; do
            NEW="\$infile"
            OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
            if [ ! -r \$OLD ]; then
              mv \$NEW \$OLD
            elif [ "\$(cat \$OLD | md5sum)" = "\$(cat \$NEW | md5sum)" ]; then
            rm \$NEW
            fi
            done
           }

        preserve_perms() {
          NEW="\$1"
          OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
          if [ -e \$OLD ]; then
            cp -a \$OLD \${NEW}.incoming
            cat \$NEW > \${NEW}.incoming
            mv \${NEW}.incoming \$NEW
          fi
          config \$NEW
          }


#        preserve_perms etc/rc.d/rc.INIT.new
#        config etc/configfile.new

        if [ -x /usr/bin/fc-cache ]; then
          /usr/bin/fc-cache -fv /usr/share/fonts/
        fi

        if [ -x usr/bin/update-desktop-database ]; then
          chroot . /usr/bin/update-desktop-database usr/share/applications > /dev/null 2>&1
        fi

        if [ -d usr/share/icons/hicolor ]; then
          if [ -x /usr/bin/gtk-update-icon-cache ]; then
            chroot . /usr/bin/gtk-update-icon-cache -f -t usr/share/icons/hicolor 1> /dev/null 2> /dev/null
          fi
        fi

        if [ -e usr/share/glib-2.0/schemas ]; then
          if [ -x /usr/bin/glib-compile-schemas ]; then
            /usr/bin/glib-compile-schemas usr/share/glib-2.0/schemas >/dev/null 2>&1
          fi
        fi

        if [ -x usr/bin/update-mime-database ]; then
          chroot . /usr/bin/update-mime-database usr/share/mime >/dev/null 2>&1
        fi

MKINS
   fi
	if [ -f "$CWD"/slack-desc ]; then
	  cat "$CWD"/slack-desc > "$PKG"/install/slack-desc
	 elif [ -x "$mkdesc" ]; then
	  $mkdesc "$PRGNAM" "$SortDesc" "$LongDesc" "$Homepage" > "$PKG"/install/slack-desc
	 else
	  echo " "
	  echo "Not slack-desc found or created   :-("
	  echo "You must have a slack-desc in $CWD"
	  echo "Or you must create one. Please read lines: 25-33 of $PRGNAM.SlackBuild"
	  echo " "
	  exit 1
	fi

	if [ -f "$CWD"/slack-required ]; then
	  cat "$CWD"/slack-required > "$PKG"/install/slack-required
	fi

	if [ -f "$CWD"/slack-suggests ]; then
	  cat "$CWD"/slack-suggests > "$PKG"/install/slack-suggests
	fi

	if [ -f "$CWD"/slack-conflicts ]; then
	  cat "$CWD"/slack-conflicts > "$PKG"/install/slack-conflicts
	fi

	if [ -d "$PKG"/usr/man ]; then
	  ( cd "$PKG"/usr/man
	  find . -type f -exec gzip -9 {} \;
	  # shellcheck disable=SC2044
	  # shellcheck disable=SC2046
	  for i in $(find . -type l) ; do ln -s $(readlink "$i").gz "$i".gz ; rm "$i" ; done
	  )
	fi

	if [ -d "$PKG"/usr/info ]; then
	  gzip -9 "$PKG"/usr/info/*.info
	  rm -f "$PKG"/usr/info/dir
	fi
else
mkdir -p "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"
mv "$PKG"/usr/share/doc/"$PRGNAM" "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/ || true
mv "$PKG"/usr/share/{licenses,LICENSE} "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/ || true
 cat "$CWD"/"$PRGNAM".SlackBuild > "$PKG"/usr/doc/"$PRGNAM"-"$VERSION"/"$PRGNAM".SlackBuild
	  find "$PKG"/usr/doc/"$PRGNAM"-"$VERSION" -type f -exec chmod 644 {} \;

	  mkdir -p "$PKG"/install
     if [ -f "$CWD"/doinst.sh ]; then
	  cat "$CWD"/doinst.sh >> "$PKG"/install/doinst.sh
	elif [ -f "$CWD"/doinst.sh.gz ]; then
	  zcat "$CWD"/doinst.sh.gz >> "$PKG"/install/doinst.sh
	else

 cat <<MKINS >> "$PKG"/install/doinst.sh
     config() {
       for infile in \$1; do
         NEW="\$infile"
         OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
         if [ ! -r \$OLD ]; then
           mv \$NEW \$OLD
         elif [ "\$(cat \$OLD | md5sum)" = "\$(cat \$NEW | md5sum)" ]; then
         rm \$NEW
         fi
         done
        }

     preserve_perms() {
       NEW="\$1"
       OLD="\$(dirname \$NEW)/\$(basename \$NEW .new)"
       if [ -e \$OLD ]; then
         cp -a \$OLD \${NEW}.incoming
         cat \$NEW > \${NEW}.incoming
         mv \${NEW}.incoming \$NEW
       fi
       config \$NEW
       }


 #   preserve_perms etc/rc.d/rc.INIT.new
 #   config etc/configfile.new

     if [ -x /usr/bin/fc-cache ]; then
       /usr/bin/fc-cache -fv /usr/share/fonts/
     fi

     if [ -x usr/bin/update-desktop-database ]; then
       chroot . /usr/bin/update-desktop-database usr/share/applications > /dev/null 2>&1
     fi

     if [ -d usr/share/icons/hicolor ]; then
       if [ -x /usr/bin/gtk-update-icon-cache ]; then
         chroot . /usr/bin/gtk-update-icon-cache -f -t usr/share/icons/hicolor 1> /dev/null 2> /dev/null
       fi
     fi

     if [ -e usr/share/glib-2.0/schemas ]; then
       if [ -x /usr/bin/glib-compile-schemas ]; then
         /usr/bin/glib-compile-schemas usr/share/glib-2.0/schemas >/dev/null 2>&1
       fi
     fi

     if [ -x usr/bin/update-mime-database ]; then
       chroot . /usr/bin/update-mime-database usr/share/mime >/dev/null 2>&1
     fi

MKINS
 fi
	if [ -f "$CWD"/slack-desc ]; then
	  cat "$CWD"/slack-desc > "$PKG"/install/slack-desc
	 elif [ -x "$mkdesc" ]; then
	  $mkdesc "$PRGNAM" "$SortDesc" "$LongDesc" "$Homepage" > "$PKG"/install/slack-desc
	 else
	  echo " "
	  echo "Not slack-desc found or created   :-("
	  echo "You must have a slack-desc in $CWD"
	  echo "Or you must create one. Please read lines: 25-33 of $PRGNAM.SlackBuild"
	  echo " "
	  exit 1
	fi

	if [ -f "$CWD"/slack-required ]; then
	  cat "$CWD"/slack-required > "$PKG"/install/slack-required
	fi

	if [ -f "$CWD"/slack-suggests ]; then
	  cat "$CWD"/slack-suggests > "$PKG"/install/slack-suggests
	fi

	if [ -f "$CWD"/slack-conflicts ]; then
	  cat "$CWD"/slack-conflicts > "$PKG"/install/slack-conflicts
	fi
fi
}


   package_build() {
   cd "$PKG" || exit 66
	  rm -f "$PKG"/{,usr/}lib${LIBDIRSUFFIX}/*.la
          rm -f "$PKG"/usr/lib/*.la || true
          rm -f "$PKG"/lib/*.la || true
	  # shellcheck disable=SC2038
	  find "$PKG" | xargs file | grep -e "executable" -e "shared object" | grep ELF \
	  | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null || true

	  # shellcheck disable=SC2038
	  find "$PKG" -name perllocal.pod \
	  -o -name ".packlist" \
	  -o -name "*.bs" \
	  | xargs rm -f

	  cd "$PKG" || exit
# add sudo here in case you build as user , else makepkg stop...
sudo  makepkg --remove-rpaths -l y -c n "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE" 2>&1 | tee "$OUTPUT"/makepkg-${PRGNAM}.log
	  echo "$DATE $Packager" | sed -e '1r /dev/stdin' "$OUTPUT/makepkg-${PRGNAM}.log" > "$OUTPUT/makepkg-${PRGNAM}.log.tmp" && mv "$OUTPUT/makepkg-${PRGNAM}.log.tmp" "$OUTPUT/makepkg-${PRGNAM}.log"


	  cd "$OUTPUT" || exit
	  md5sum $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE" > $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".md5
	  # shellcheck disable=SC2002
	  cat "$PKG"/install/slack-desc | grep "^${PRGNAM}" > $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".txt
	  cat $PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".txt > README
	if [ -f "$PKG"/install/slack-required ]; then
	  # shellcheck disable=SC2086
	  cat "$PKG"/install/slack-required > $PRGNAM-$VERSION-"$ARCH"-"$BUILD""$TAG".dep
	fi
   }

   clean_src(){
	cd "$CWD" || exit
 if [[ "$COMPRESS" == "git" ]]; then
	rm -r package-"$PRGNAM" work
  else
  # shellcheck disable=SC2035
  rm -r package-"$PRGNAM" work *.$COMPRESS
 fi
   }

   pkg_install(){
sudo upgradepkg --install-new --reinstall "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE"
   }



  sig_package(){
#  Add you id_rsa, example:
    prikey_path="/root/id_rsa"
         openssl dgst -sha256 -sign $prikey_path  -out "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE".sig "$OUTPUT"/$PRGNAM-"$VERSION"-"$ARCH"-"$BUILD""$TAG"."$PKGTYPE"
   }


   # END OF EDIT MOST OF TIMES #



download_src() {
  if [[ -z "$VERSION" || -z "$AUTO_UPD" ]]; then
    echo "$VERSION or $AUTO_UPD is not set."
    exit 1
  fi

  if [[ $AGENT == ON ]]; then
   # Use eval to construct and run the download command
    DOWNLOAD_AGENT
   else
  if [[ "$VERSION" != "$AUTO_UPD" ]]; then
    sleep 1
    if [[ $COMPRESS == "git" ]]; then
      GIT="$(which git)"
      $GIT clone "$SRCURL"
      if [[ -n "$GITCHEK" ]]; then
        cd "$SRCNAM" || cd "$PRGNAM" || exit
        $GIT checkout "$GITCHEK"
      fi
    elif [[ $COMPRESS == "svn" ]]; then
      SVN="$(which svn)"
      $SVN co "$SRCURL"
    elif [[ $COMPRESS == "cvs" ]]; then
      CVS="$(which cvs)"
      $CVS -z3 -f "$SRCURL"
    elif [[ $COMPRESS == "lftp" ]]; then
      LFTP="$(which lftp)"
      $LFTP -c mirror "$SRCURL"
    elif [[ $COMPRESS == "deb" ]]; then
      wget -c $SRCURL
    elif [[ $COMPRESS == "rpm" ]]; then
      wget -c $SRCURL
    else
      wget -O "$SRCNAM"-"$VERSION"."$COMPRESS" "$SRCURL"
    fi
  elif [[ "$VERSION" == "$AUTO_UPD" ]]; then
    # If the release version is "null", fall back to fetching from tags
    if [[ "$VERSION" == "null" || -z "$VERSION" ]]; then
      # Get the latest tag if release is not available
      VERSION=$(curl --silent -L "https://api.github.com/repos/$DEV/$PRJ/tags" | jq -r '.[0].name' | sed 's/^v//')
      echo "Falling back to latest tag: $VERSION"
      wget -c https://github.com/"$DEV"/"$PRJ"/archive/v"$VERSION"/"$SRCNAM"-"$VERSION"."$COMPRESS"
    else
    echo "Latest release version: $VERSION"
      wget -c https://github.com/"$DEV"/"$PRJ"/releases/download/"$VERSION"/"$SRCNAM"-"$VERSION"."$COMPRESS" || wget -O "$SRCNAM"-"$VERSION"."$COMPRESS" https://github.com/"$DEV"/"$PRJ"/archive/refs/tags/"$VERSION"."$COMPRESS"
    fi
  else
    echo "Download_src Messed up $VERSION"
    exit 8
  fi
fi
}

chrooting(){
   	chown -R root:root .
	find -L . \
	  \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 \
	  -o -perm 511 \) -exec chmod 755 {} \; -o \
	  \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 \
	  -o -perm 440 -o -perm 400 \) -exec chmod 644 {} \;
   }


prepare_build(){
	rm -rf "$PKG" "$OUTPUT" "$COMPRESS"
	mkdir -p "$TMP" "$PKG" "$OUTPUT"
	rm -rf "$TMP"/$PRGNAM-"$VERSION"

# Check if MDSCHK is empty
if [ -z "$MDSCHK" ]; then
  echo "NO MDSCHK provided. Proceeding without it: $MDSCHK"
else
  # Possible filenames to check
  possible_files=(
    "$PRGNAM-$VERSION.$COMPRESS"
    "$SRCNAM-$VERSION.$COMPRESS"
    "$PRGNAM.$COMPRESS"
    "$SRCNAM.$COMPRESS"
    "$PRGNAM"
    "$SRCNAM"
  )

  # Find the first existing file
  found_file=""
  for file in "${possible_files[@]}"; do
    if [[ -f "$file" ]]; then
      found_file="$file"
      break  # Exit the loop as soon as we find an existing file
    fi
  done

  # Verify checksum if a file was found
  if [[ -n "$found_file" ]]; then
    echo "Found file: $found_file. Checking MD5..."
    if echo "$MDSCHK  $found_file" | md5sum -c -; then
      echo "Checksum matches for $found_file. Proceeding..."
      exit 0  # Exit successfully if checksum matches
    else
      echo "Checksum verification failed for $found_file."
    fi
  else
    echo "No file found. Preparing to re-download..."
  fi

  # Delete possible files and re-download if checksum fails or no file found
  echo "Deleting existing files and re-downloading..."
  for file in "${possible_files[@]}"; do
    rm -rf "$file"
  done
  download_src  # Call the function to re-download sources
fi

	get_out() {
    if [ -f "$1" ] ; then
        case "$1" in
            *.tar.bz2)  tar xvjf "$1" ;;
            *.tar.gz)   tar xvzf "$1" ;;
            *.tar.xz)   tar xvJf "$1" ;;
            *.bz2)      bunzip2 "$1"  ;;
            *.rar)      rar x "$1"    ;;
            *.gz)       gunzip "$1"   ;;
            *.tar)      tar xvf "$1"  ;;
            *.tbz2)     tar xvjf "$1" ;;
            *.tgz)      tar xvzf "$1" ;;
            *.zip)      unzip "$1"    ;;
            *.Z)        uncompress "$1" ;;
            *.7z)       7z x "$1"     ;;
            *)          echo "Error: Don't know how to extract '$1'." ;;
        esac
    elif [ -n "$SRCNAM" ] && [ -n "$VERSION" ] && [ -f "$SRCNAM-$VERSION" ]; then
        case "$SRCNAM-$VERSION" in
            *.tar.bz2)  tar xvjf "$SRCNAM-$VERSION" ;;
            *.tar.gz)   tar xvzf "$SRCNAM-$VERSION" ;;
            *.tar.xz)   tar xvJf "$SRCNAM-$VERSION" ;;
            *.bz2)      bunzip2 "$SRCNAM-$VERSION"  ;;
            *.rar)      rar x "$SRCNAM-$VERSION"    ;;
            *.gz)       gunzip "$SRCNAM-$VERSION"   ;;
            *.tar)      tar xvf "$SRCNAM-$VERSION"  ;;
            *.tbz2)     tar xvjf "$SRCNAM-$VERSION" ;;
            *.tgz)      tar xvzf "$SRCNAM-$VERSION" ;;
            *.zip)      unzip "$SRCNAM-$VERSION"    ;;
            *.Z)        uncompress "$SRCNAM-$VERSION" ;;
            *.7z)       7z x "$SRCNAM-$VERSION"     ;;
            *)          echo "Error: Don't know how to extract '$SRCNAM-$VERSION'." ;;
        esac
    else
        echo "Error: '$1' is not a valid file!"
    fi

    if [[ ! -e "$CWD/README" && ! -e "$CWD/README.md" ]]; then
      # If neither file exists, create README
      echo "Creating README in: $CWD"
      # shellcheck disable=SC2188
      > "$CWD/README"
      echo "$PRGNAM $SortDesc" > "$CWD/README"
    else
    pwd
      echo "README or README.md already exists, skipping creation."
    fi
}


cd "$TMP" || exit
if [[ $COMPRESS != "git" && $COMPRESS != "svn" && $COMPRESS != "cvs" && $COMPRESS != "lftp" && $COMPRESS != "rpm" && $COMPRESS != "deb" && $COMPRESS != "AppImage" ]]; then
  get_out "$CWD"/"$SRCNAM"-"$VERSION"."$COMPRESS" || get_out "$CWD"/"$SRCNAM"."$COMPRESS" || exit
  if [[ $BIN_PKG != "YES" ]]; then
     cd $SRCNAM-"$VERSION" || cd $PRGNAM-"$VERSION" || cd $SRCNAM || exit
    else
     echo "BIN_PKG = $BIN_PKG"
  fi
  echo "hm...lets continue and see what happens"
  else
   if [[ $COMPRESS = "deb" ]]; then
    cd "$CWD"
    ar x $SRCNAM.$COMPRESS
	rm debian-binary control.tar.xz
	tar -xJf data.tar.xz -C "$PKG"
  elif
    [[ $COMPRESS == "AppImage" ]]; then
    echo "$COMPRESS="AppImage""
    mv "$CWD"/"$SRCNAM" "$TMP"
  elif
    [[ $COMPRESS = "rpm" ]]; then
    cd "$CWD"
    rpm -Kv "$SRCNAM.$COMPRESS"
    rpm2cpio "$SRCNAM"."$COMPRESS" > "$TMP"/"$SRCNAM"."$COMPRESS".cpio
  else
   mv "$CWD"/"$SRCNAM" "$TMP"
   cd $SRCNAM || cd $PRGNAM ||exit
   fi
fi
}
# here ^^ end prepare_build function ;) #

# Detect the architecture if not already set
if [ -z "$ARCH" ]; then
  case "$(uname -m)" in
    i386) ARCH=i586 ;;          # 32-bit Intel architecture
    i686) ARCH=i686 ;;          # 32-bit Intel architecture (optimized)
    x86_64) ARCH=x86_64 ;;      # 64-bit Intel architecture
    armv7* | armhf) ARCH=armv7 ;;  # ARMv7 (32-bit, hardware float)
    armv6* | armv5*) ARCH=armv6 ;;  # ARMv6 (32-bit)
    aarch64 | arm64) ARCH=aarch64 ;;  # ARMv8 (64-bit)
    ppc | ppc64) ARCH=ppc ;;     # PowerPC (32-bit or 64-bit)
    s390x) ARCH=s390x ;;        # IBM System Z (64-bit)
    mips*) ARCH=mips ;;         # MIPS (various variants)
    riscv64) ARCH=riscv64 ;;    # RISC-V 64-bit
    sparc64) ARCH=sparc64 ;;     # SPARC (64-bit)
    *)
      echo "Error: Unsupported architecture '$(uname -m)'. Exiting."
      exit 1
      ;;
  esac
fi

echo "Detected architecture: $ARCH"

# Output package name if required
# shellcheck disable=SC2236
if [ ! -z "${PRINT_PACKAGE_NAME}" ]; then
  echo "${PRGNAM}-${VERSION}-${ARCH}-${BUILD}${TAG}.${PKGTYPE}"
  exit 0
fi

# Check if ARCH is set (redundant here, but kept for safety)
if [ -z "$ARCH" ]; then
  echo "Error: ARCH variable is not set. Please set it to the target architecture."
  exit 1
fi

# Set compiler flags based on architecture for musl/GCC
case "$ARCH" in
  "i586")
    SLKCFLAGS="-O2 -march=i586 -mtune=i686"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -march=i586 -mtune=i686"
    QMAKE_CXXFLAGS="-O2 -m32 -march=i586 -mtune=i686"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "i686")
    SLKCFLAGS="-O2 -march=i686 -mtune=i686"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -march=i686 -mtune=i686"
    QMAKE_CXXFLAGS="-O2 -m32 -march=i686 -mtune=i686"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "x86_64")
    SLKCFLAGS="-O2 -march=x86-64 -mtune=generic -fPIC"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -m64 -march=x86-64 -mtune=generic -fPIC"
    QMAKE_CXXFLAGS="-O2 -m64 -march=x86-64 -mtune=generic -fPIC"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  "armv7")
    SLKCFLAGS="-O2 -march=armv7-a -mtune=generic -fPIC"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -march=armv7-a -mtune=generic -fPIC"
    QMAKE_CXXFLAGS="-O2 -m32 -march=armv7-a -mtune=generic -fPIC"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "armv6")
    SLKCFLAGS="-O2 -march=armv6 -mtune=generic -fPIC"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -march=armv6 -mtune=generic -fPIC"
    QMAKE_CXXFLAGS="-O2 -m32 -march=armv6 -mtune=generic -fPIC"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "aarch64")
    SLKCFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
    QMAKE_CXXFLAGS="-O2 -march=armv8-a -mtune=generic -fPIC"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  "ppc")
    SLKCFLAGS="-O2 -mppc"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -mppc"
    QMAKE_CXXFLAGS="-O2 -m32 -mppc"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "ppc64")
    SLKCFLAGS="-O2 -mppc64"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -m64 -mppc64"
    QMAKE_CXXFLAGS="-O2 -m64 -mppc64"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  "s390x")
    SLKCFLAGS="-O2 -march=s390x"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -m64 -march=s390x"
    QMAKE_CXXFLAGS="-O2 -m64 -march=s390x"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  "mips")
    SLKCFLAGS="-O2 -march=mips32"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2 -m32 -march=mips32"
    QMAKE_CXXFLAGS="-O2 -m32 -march=mips32"
    QMAKE_LFLAGS="-L/usr/lib -L/usr/local/lib"
    ;;

  "riscv64")
    SLKCFLAGS="-O2 -march=rv64imac -mabi=lp64"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -m64 -march=rv64imac -mabi=lp64"
    QMAKE_CXXFLAGS="-O2 -m64 -march=rv64imac -mabi=lp64"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  "sparc64")
    SLKCFLAGS="-O2 -m64"
    LIBDIRSUFFIX="64"
    QMAKE_CFLAGS="-O2 -m64"
    QMAKE_CXXFLAGS="-O2 -m64"
    QMAKE_LFLAGS="-L/usr/lib64 -L/usr/local/lib64"
    ;;

  *)
    echo "Warning: Unsupported architecture '$ARCH'. Using generic flags."
    SLKCFLAGS="-O2"
    LIBDIRSUFFIX=""
    QMAKE_CFLAGS="-O2"
    QMAKE_CXXFLAGS="-O2"
    QMAKE_LFLAGS="-L/usr/lib"
    ;;
esac



NUMJOBS=${NUMJOBS:-"-j$(getconf _NPROCESSORS_ONLN)"}

#DOCS="AUTHORS ChangeLog* COPYING CREDITS FAQ GPL* HACKING LICENSE MAINTAINERS NEWS README* TODO"
#DOCS_DIR="docs DOCS"

  set -e
  
UMASKBKP=$(umask)
umask 0022

# For future TODO use...
DEPCHK=""
OPTDEP=""

# default most of times exept custom_build() or if you build as user (no chrooting)#
download_src
prepare_build
patch_build
# DONT chroot if deb or rpm or if golang_build
chrooting

# uncomment what you need:
#auto_build
#meson_build
#python_build
#cmake_build
#qmake6_build
#debian_build
#rpm_build
#perl_build
#haskel_build
#cargo_build
#golang_build
appimage_build
#custom_build

# default most of times #
after_build
package_build

# uncomment what you need:
#pkg_install
sig_package
clean_src

umask ${UMASKBKP}
# Calculate and display build time
end_time=$(date +%s)
elapsed_time=$((end_time - start_time))
echo "Build process completed in $((elapsed_time / 60)) minutes and $((elapsed_time % 60)) seconds."
